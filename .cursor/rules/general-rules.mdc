---
description: 
globs: 
alwaysApply: true
---
# auxOS General Rules

## Environment
- Project: `react`
- Framework: `tailwindcss`, `shadcn`, `vite`
- Package Manager: `bun`
- Bundler: `bunx`

## General folder structure
- `api/`: API endpoints
- `public/`: Static assets
  - `assets/`: Videos, sounds, and other media
  - `fonts/`: Font files
  - `icons/`: UI icons organized by category
  - `patterns/`: Pattern files
  - `wallpapers/`: Wallpaper images (photos and tiles)
- `src/`: Source code
  - `apps/`: Individual application modules
    - Each app has its own directory with components, hooks, and utilities
  - `components/`: Shared React components
    - `dialogs/`: Dialog components
    - `layout/`: Layout components
    - `shared/`: Shared components across applications
    - `ui/`: UI components (shadcn components)
  - `config/`: Configuration files
  - `contexts/`: React context providers
  - `hooks/`: Custom React hooks
  - `lib/`: Libraries and utilities
  - `stores/`: State management
  - `styles/`: CSS and styling utilities
  - `types/`: TypeScript type definitions
  - `utils/`: Utility functions

### App Structure
- App components follow the naming convention `[AppName]AppComponent.tsx`
- Apps are organized in `src/apps/[app-name]/` directories
- Each app folder typically contains:
  - `components/`: App-specific components
  - `hooks/`: Custom hooks specific to the app
  - `utils/`: Utility functions for the app
- The main app component is exported from `src/apps/[app-name]/index.tsx`
- App components receive common props via the `AppProps` interface
- Window appearance is handled via the shared `WindowFrame` component
- Each app defines its own app-specific menu bar component

### State Management
- Apps use a combination of local state (React hooks) and global state (stores)
- Stores are defined in `src/stores/` with a naming pattern of `use[Store]Store`
- Stores are implemented using a state management library (Zustand)

### Component Organization
- Shared UI components from `@/components/ui/` follow shadcn patterns
- Dialog components from `@/components/dialogs/` handle common dialog patterns
- Custom hooks from `@/hooks/` provide reusable functionality
- Apps leverage shared components but define app-specific UI in their own components folder
```regex
import.*from.*@/components/ui/(alert|button|card|dialog|dropdown-menu|input|label|menubar|scroll-area|select|slider|switch|table|tabs|tooltip)
```
‚ö†Ô∏è Run: `bunx --bun shadcn@latest add $1`

### Custom Components
These are custom implementations (not shadcn):
- `audio-input-button`
- `audio-bars`
- `volume-bar`

## Operational Doctrine Updates (Agent Lessons)

These are durable, actionable rules distilled from recent agent sessions. They are intended to be applied by automated agents and human reviewers working in this repository.

1. Agent Execution Environment
- When the repository declares a preferred `packageManager` (for example `bun` in this project), verify the runtime has that tool installed before using it.
- If the preferred tool is absent, choose a documented, minimally-invasive fallback (for example `npm install`), record the substitution, and continue. Do not assume the fallback is identical; note any behavioural differences in session logs.

2. Read-Before-Write / Read-After-Write
- Always read a target file immediately before editing it. Record the pre-edit intent and the exact lines (or region) you will modify.
- After applying any edit, re-read the file and verify the change was applied and that syntax/formatting remains valid. If verification fails, revert or create a corrective patch.

3. Safe Command Execution
- All shell commands executed by an agent must use a timeout wrapper and non-interactive flags where applicable (timeout 120s bash -lc "..."). Capture stdout and stderr for diagnostics.

4. Reconnaissance Discipline
- Reconnaissance phases must be read-only. Do not mutate files, configuration, or external services during reconnaissance. Any mutations must be explicitly part of a further, authorized remediation phase.

5. System-Wide Ownership when Fixing Shared Components
- If a fix touches a shared library or component, enumerate and audit all known consumers. Run targeted tests and lints for each affected consumer and apply follow-up fixes where necessary.

6. Reporting and TODO Ledger
- Maintain an inline TODO ledger in major reports with ‚úÖ (done), ‚ö†Ô∏è (warning/needs attention), and üöß (blocker) markers. Include the ledger in the session's final report.

7. Doctrine Evolution Protocol
- Agents must proactively add durable lessons to project doctrine files when they meet the quality filter: universal & reusable, abstracted, and high-impact. Prefer improving existing rules over appending duplicates.

Integration Procedure (how to apply doctrine updates safely):
- Search for existing rule file(s) under `.cursor/` and similar locations.
- Read the file, find the most logical section, and either refine an existing rule or add a new, well-scoped rule.
- After editing, re-open the edited file, run relevant linters or simple builds if applicable, and record the diff in the session report.

